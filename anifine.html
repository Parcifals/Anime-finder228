<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üç• Ultimate Anime Finder</title>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --error: #e74c3c;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        h1 {
            color: var(--dark);
            margin-bottom: 10px;
        }
        .subtitle {
            color: #7f8c8d;
        }
        .search-section {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .search-input-container {
            flex: 1;
            min-width: 300px;
        }
        #animeInput {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        #animeInput:focus {
            border-color: var(--primary);
            outline: none;
        }
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        select, .filter-btn {
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
        }
        .filter-btn {
            background-color: var(--light);
            transition: all 0.3s;
        }
        .filter-btn:hover {
            background-color: #ddd;
        }
        .filter-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        button {
            background-color: var(--primary);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .api-selector {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .api-option {
            padding: 8px 12px;
            border-radius: 20px;
            background: var(--light);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .api-option.active {
            background: var(--primary);
            color: white;
        }
        #results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        .anime-card {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
        }
        .anime-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
        }
        .anime-card img {
            width: 100%;
            height: 350px;
            object-fit: cover;
        }
        .anime-info {
            padding: 15px;
        }
        .anime-info h3 {
            margin: 0 0 10px;
            font-size: 18px;
            color: var(--dark);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .score {
            display: inline-block;
            background-color: #f39c12;
            color: white;
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .genres {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        .genre {
            background-color: var(--light);
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 12px;
        }
        .description {
            font-size: 14px;
            color: #7f8c8d;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .meta {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #95a5a6;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #7f8c8d;
            grid-column: 1 / -1;
        }
        .error {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: var(--error);
            grid-column: 1 / -1;
        }
        .cache-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #95a5a6;
            font-size: 14px;
        }
        @media (max-width: 768px) {
            #results {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            }
            .anime-card img {
                height: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üç• Ultimate Anime Finder</h1>
            <p class="subtitle">–ü–æ–∏—Å–∫ –ø–æ AniList, MyAnimeList –∏ Jikan API —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º</p>
        </header>
        
        <section class="search-section">
            <div class="search-input-container">
                <input type="text" id="animeInput" placeholder="–ù–∞—á–Ω–∏—Ç–µ –≤–≤–æ–¥–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –∞–Ω–∏–º–µ..." autocomplete="off">
                <div class="filters">
                    <select id="genreFilter">
                        <option value="">–í—Å–µ –∂–∞–Ω—Ä—ã</option>
                        <option value="Action">–≠–∫—à–µ–Ω</option>
                        <option value="Adventure">–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è</option>
                        <option value="Comedy">–ö–æ–º–µ–¥–∏—è</option>
                        <option value="Drama">–î—Ä–∞–º–∞</option>
                        <option value="Fantasy">–§—ç–Ω—Ç–µ–∑–∏</option>
                        <option value="Romance">–†–æ–º–∞–Ω—Ç–∏–∫–∞</option>
                        <option value="Sci-Fi">–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞</option>
                        <option value="Horror">–£–∂–∞—Å—ã</option>
                    </select>
                    
                    <select id="yearFilter">
                        <option value="">–í—Å–µ –≥–æ–¥—ã</option>
                        <option value="2023">2023</option>
                        <option value="2022">2022</option>
                        <option value="2021">2021</option>
                        <option value="2020">2020</option>
                        <option value="2019">2019</option>
                        <option value="2010-2018">2010-2018</option>
                        <option value="2000-2009">2000-2009</option>
                        <option value="1990-1999">1990-1999</option>
                    </select>
                    
                    <select id="statusFilter">
                        <option value="">–í—Å–µ —Å—Ç–∞—Ç—É—Å—ã</option>
                        <option value="RELEASING">–û–Ω–≥–æ–∏–Ω–≥</option>
                        <option value="FINISHED">–ó–∞–≤–µ—Ä—à—ë–Ω</option>
                        <option value="NOT_YET_RELEASED">–ï—â—ë –Ω–µ –≤—ã—à–µ–ª</option>
                    </select>
                </div>
                
                <div class="api-selector">
                    <div class="api-option active" data-api="anilist">AniList</div>
                    <div class="api-option" data-api="jikan">Jikan (MAL)</div>
                    <div class="api-option" data-api="kitsu">Kitsu</div>
                </div>
            </div>
            
            <button id="searchButton">–ü–æ–∏—Å–∫</button>
        </section>
        
        <div id="results"></div>
        
        <footer>
            –î–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—Ç—Å—è AniList, MyAnimeList –∏ Kitsu API<br>
            –ö—ç—à —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ
        </footer>
    </div>

    <script>
        // ========== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ==========
        const CONFIG = {
            cacheExpiry: 24 * 60 * 60 * 1000, // 24 —á–∞—Å–∞
            debounceTime: 500, // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –ø–æ–∏—Å–∫–æ–º
            perPage: 12, // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É
            defaultAPI: 'anilist'
        };

        // ========== –°–û–°–¢–û–Ø–ù–ò–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ==========
        let state = {
            query: '',
            page: 1,
            isLoading: false,
            hasMore: true,
            selectedAPI: CONFIG.defaultAPI,
            filters: {
                genre: '',
                year: '',
                status: ''
            }
        };

        // ========== –≠–õ–ï–ú–ï–ù–¢–´ –î–û–ú ==========
        const elements = {
            input: document.getElementById('animeInput'),
            button: document.getElementById('searchButton'),
            results: document.getElementById('results'),
            genreFilter: document.getElementById('genreFilter'),
            yearFilter: document.getElementById('yearFilter'),
            statusFilter: document.getElementById('statusFilter'),
            apiOptions: document.querySelectorAll('.api-option')
        };

        // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
        init();

        function init() {
            // –ó–∞–≥—Ä—É–∑–∫–∞ –∫—ç—à–∞ –∏–∑ localStorage
            loadCache();
            
            // –°–æ–±—ã—Ç–∏—è
            elements.input.addEventListener('input', debounce(handleSearch, CONFIG.debounceTime));
            elements.button.addEventListener('click', handleSearch);
            elements.genreFilter.addEventListener('change', updateFilters);
            elements.yearFilter.addEventListener('change', updateFilters);
            elements.statusFilter.addEventListener('change', updateFilters);
            
            // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ API
            elements.apiOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.apiOptions.forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    state.selectedAPI = option.dataset.api;
                    resetSearch();
                });
            });
            
            // –ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞
            window.addEventListener('scroll', handleInfiniteScroll);
            
            // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –∞–Ω–∏–º–µ
            loadPopular();
        }

        // ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
        async function handleSearch() {
            state.query = elements.input.value.trim();
            state.page = 1;
            state.hasMore = true;
            
            if (!state.query) {
                loadPopular();
                return;
            }
            
            await searchAnime();
        }

        async function searchAnime() {
            if (state.isLoading || !state.hasMore) return;
            
            state.isLoading = true;
            updateUI();
            
            try {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—ç—à–∞
                const cacheKey = generateCacheKey();
                const cachedData = getFromCache(cacheKey);
                
                if (cachedData) {
                    displayResults(cachedData.data, true);
                    return;
                }
                
                // –ó–∞–ø—Ä–æ—Å –∫ API
                let data;
                switch (state.selectedAPI) {
                    case 'anilist':
                        data = await fetchAniList();
                        break;
                    case 'jikan':
                        data = await fetchJikan();
                        break;
                    case 'kitsu':
                        data = await fetchKitsu();
                        break;
                }
                
                // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∫—ç—à
                saveToCache(cacheKey, data);
                displayResults(data);
                
            } catch (error) {
                showError(error.message);
            } finally {
                state.isLoading = false;
                updateUI();
            }
        }

        function handleInfiniteScroll() {
            const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
            const isBottom = scrollTop + clientHeight >= scrollHeight - 500;
            
            if (isBottom && !state.isLoading && state.hasMore && state.query) {
                state.page++;
                searchAnime();
            }
        }

        function updateFilters() {
            state.filters = {
                genre: elements.genreFilter.value,
                year: elements.yearFilter.value,
                status: elements.statusFilter.value
            };
            resetSearch();
        }

        function resetSearch() {
            state.page = 1;
            state.hasMore = true;
            elements.results.innerHTML = '';
            if (state.query) {
                searchAnime();
            } else {
                loadPopular();
            }
        }

        // ========== API –§–£–ù–ö–¶–ò–ò ==========
        async function fetchAniList() {
            const genreFilter = state.filters.genre ? `genres: "${state.filters.genre}"` : '';
            const yearFilter = state.filters.year ? getAniListYearFilter() : '';
            const statusFilter = state.filters.status ? `status: ${state.filters.status}` : '';
            
            const query = `
                query ($search: String, $page: Int, $perPage: Int) {
                    Page(page: $page, perPage: $perPage) {
                        pageInfo {
                            hasNextPage
                        }
                        media(search: $search, type: ANIME, sort: POPULARITY_DESC, ${genreFilter} ${yearFilter} ${statusFilter}) {
                            id
                            title {
                                romaji
                                english
                                native
                            }
                            coverImage {
                                large
                            }
                            description
                            genres
                            averageScore
                            status
                            startDate {
                                year
                            }
                        }
                    }
                }
            `;
            
            const variables = {
                search: state.query,
                page: state.page,
                perPage: CONFIG.perPage
            };
            
            const response = await fetch("https://graphql.anilist.co", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                },
                body: JSON.stringify({
                    query,
                    variables
                })
            });
            
            const data = await response.json();
            return {
                data: data.data.Page.media,
                hasMore: data.data.Page.pageInfo.hasNextPage
            };
        }
        
        function getAniListYearFilter() {
            if (state.filters.year.includes('-')) {
                const [start, end] = state.filters.year.split('-').map(Number);
                return `startDate_greater: ${start}, startDate_lesser: ${end}`;
            }
            return `startDate_like: "${state.filters.year}%"`;
        }

        async function fetchJikan() {
            let url = `https://api.jikan.moe/v4/anime?q=${encodeURIComponent(state.query)}&page=${state.page}&limit=${CONFIG.perPage}`;
            
            if (state.filters.genre) {
                url += `&genres=${state.filters.genre}`;
            }
            if (state.filters.year && !state.filters.year.includes('-')) {
                url += `&year=${state.filters.year}`;
            }
            if (state.filters.status) {
                url += `&status=${state.filters.status.toLowerCase()}`;
            }
            
            const response = await fetch(url);
            const data = await response.json();
            
            return {
                data: data.data,
                hasMore: data.pagination.has_next_page
            };
        }

        async function fetchKitsu() {
            let filterStr = '';
            if (state.filters.genre) {
                filterStr += `&filter[genres]=${state.filters.genre}`;
            }
            if (state.filters.year) {
                filterStr += `&filter[year]=${state.filters.year}`;
            }
            if (state.filters.status) {
                filterStr += `&filter[status]=${state.filters.status.toLowerCase()}`;
            }
            
            const response = await fetch(`https://kitsu.io/api/edge/anime?filter[text]=${encodeURIComponent(state.query)}&page[limit]=${CONFIG.perPage}&page[offset]=${(state.page - 1) * CONFIG.perPage}${filterStr}`);
            const data = await response.json();
            
            return {
                data: data.data,
                hasMore: !!data.links.next
            };
        }

        async function loadPopular() {
            state.isLoading = true;
            elements.results.innerHTML = '<div class="loading">–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –∞–Ω–∏–º–µ...</div>';
            
            try {
                const cacheKey = 'popular_' + state.selectedAPI;
                const cachedData = getFromCache(cacheKey);
                
                if (cachedData) {
                    displayResults(cachedData.data, true);
                    return;
                }
                
                let data;
                switch (state.selectedAPI) {
                    case 'anilist':
                        data = await fetchPopularAniList();
                        break;
                    case 'jikan':
                        data = await fetchPopularJikan();
                        break;
                    case 'kitsu':
                        data = await fetchPopularKitsu();
                        break;
                }
                
                saveToCache(cacheKey, data);
                displayResults(data);
                
            } catch (error) {
                showError(error.message);
            } finally {
                state.isLoading = false;
            }
        }

        // ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ==========
        function displayResults(result, fromCache = false) {
            const { data, hasMore } = result;
            state.hasMore = hasMore;
            
            if (state.page === 1) {
                elements.results.innerHTML = '';
            }
            
            if (!data || data.length === 0) {
                if (state.page === 1) {
                    elements.results.innerHTML = '<div class="error">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ üò¢</div>';
                }
                return;
            }
            
            const fragment = document.createDocumentFragment();
            
            data.forEach(item => {
                const anime = normalizeAnimeData(item, state.selectedAPI);
                const card = createAnimeCard(anime, fromCache);
                fragment.appendChild(card);
            });
            
            elements.results.appendChild(fragment);
            
            if (state.isLoading) {
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'loading';
                loadingDiv.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞...';
                elements.results.appendChild(loadingDiv);
            }
        }

        function normalizeAnimeData(item, api) {
            switch (api) {
                case 'anilist':
                    return {
                        id: item.id,
                        title: item.title.romaji || item.title.english || item.title.native,
                        image: item.coverImage?.large || 'https://via.placeholder.com/300x450?text=No+Image',
                        description: item.description,
                        genres: item.genres || [],
                        score: item.averageScore,
                        year: item.startDate?.year
                    };
                case 'jikan':
                    return {
                        id: item.mal_id,
                        title: item.title,
                        image: item.images?.jpg?.large_image_url || item.images?.jpg?.image_url || 'https://via.placeholder.com/300x450?text=No+Image',
                        description: item.synopsis,
                        genres: item.genres?.map(g => g.name) || [],
                        score: item.score,
                        year: item.year
                    };
                case 'kitsu':
                    return {
                        id: item.id,
                        title: item.attributes.titles.en_jp || item.attributes.titles.en || item.attributes.canonicalTitle,
                        image: item.attributes.posterImage?.large || item.attributes.posterImage?.medium || 'https://via.placeholder.com/300x450?text=No+Image',
                        description: item.attributes.synopsis,
                        genres: [], // Kitsu —Ç—Ä–µ–±—É–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –∂–∞–Ω—Ä–æ–≤
                        score: item.attributes.averageRating ? Math.round(item.attributes.averageRating / 10) : null,
                        year: item.attributes.startDate?.substring(0, 4)
                    };
            }
        }

        function createAnimeCard(anime, fromCache) {
            const card = document.createElement('div');
            card.className = 'anime-card';
            
            let html = `
                <img src="${anime.image}" alt="${anime.title}" loading="lazy">
                <div class="anime-info">
                    <h3>${anime.title}</h3>
                    ${anime.score ? `<div class="score">‚òÖ ${anime.score}/100</div>` : ''}
                    <div class="genres">
                        ${anime.genres.slice(0, 3).map(genre => `<span class="genre">${genre}</span>`).join('')}
                    </div>
                    <p class="description">${anime.description ? anime.description.replace(/<[^>]*>/g, "").substring(0, 100) + "..." : "–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è"}</p>
                    <div class="meta">
                        <span>${anime.year || '–ì–æ–¥ –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'}</span>
                    </div>
                </div>
            `;
            
            if (fromCache) {
                html += `<div class="cache-indicator">–ö—ç—à</div>`;
            }
            
            card.innerHTML = html;
            return card;
        }

        function showError(message) {
            elements.results.innerHTML = `<div class="error">–û—à–∏–±–∫–∞: ${message}</div>`;
        }

        function updateUI() {
            elements.button.disabled = state.isLoading;
        }

        // ========== –ö–≠–®–ò–†–û–í–ê–ù–ò–ï ==========
        function generateCacheKey() {
            return `${state.selectedAPI}_${state.query}_${state.page}_${state.filters.genre}_${state.filters.year}_${state.filters.status}`;
        }

        function saveToCache(key, data) {
            const cache = {
                data,
                timestamp: Date.now()
            };
            
            localStorage.setItem(key, JSON.stringify(cache));
        }

        function getFromCache(key) {
            const cached = localStorage.getItem(key);
            if (!cached) return null;
            
            const parsed = JSON.parse(cached);
            const isExpired = Date.now() - parsed.timestamp > CONFIG.cacheExpiry;
            
            return isExpired ? null : parsed;
        }

        function loadCache() {
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—á–∏—Å—Ç–∫—É —É—Å—Ç–∞—Ä–µ–≤—à–µ–≥–æ –∫—ç—à–∞
            console.log('–ö—ç—à –∑–∞–≥—Ä—É–∂–µ–Ω');
        }

        // ========== –ü–û–ü–£–õ–Ø–†–ù–´–ï –ó–ê–ü–†–û–°–´ ==========
        async function fetchPopularAniList() {
            const query = `
                query ($page: Int, $perPage: Int) {
                    Page(page: $page, perPage: $perPage) {
                        pageInfo {
                            hasNextPage
                        }
                        media(type: ANIME, sort: POPULARITY_DESC) {
                            id
                            title {
                                romaji
                                english
                                native
                            }
                            coverImage {
                                large
                            }
                            description
                            genres
                            averageScore
                            startDate {
                                year
                            }
                        }
                    }
                }
            `;
            
            const response = await fetch("https://graphql.anilist.co", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                },
                body: JSON.stringify({
                    query,
                    variables: {
                        page: 1,
                        perPage: CONFIG.perPage
                    }
                })
            });
            
            const data = await response.json();
            return {
                data: data.data.Page.media,
                hasMore: data.data.Page.pageInfo.hasNextPage
            };
        }

        async function fetchPopularJikan() {
            const response = await fetch(`https://api.jikan.moe/v4/top/anime?limit=${CONFIG.perPage}`);
            const data = await response.json();
            return {
                data: data.data,
                hasMore: false
            };
        }

        async function fetchPopularKitsu() {
            const response = await fetch(`https://kitsu.io/api/edge/anime?sort=popularityRank&page[limit]=${CONFIG.perPage}`);
            const data = await response.json();
            return {
                data: data.data,
                hasMore: false
            };
        }

        // ========== –£–¢–ò–õ–ò–¢–´ ==========
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }
    </script>
</body>
</html>